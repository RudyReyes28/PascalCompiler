package com.rudyreyes.pascalcompiler.controlador.analisis;

//importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import com.rudyreyes.pascalcompiler.modelo.abstracto.Instruccion;
import com.rudyreyes.pascalcompiler.modelo.simbolo.*;
import java.util.HashMap;
import java.util.Collections;
//instrucciones
import com.rudyreyes.pascalcompiler.modelo.instrucciones.writeln.*;
import com.rudyreyes.pascalcompiler.modelo.instrucciones.variables.*;
import com.rudyreyes.pascalcompiler.modelo.instrucciones.sentenciasControl.*;
import com.rudyreyes.pascalcompiler.modelo.instrucciones.tipos.*;
import com.rudyreyes.pascalcompiler.modelo.instrucciones.ciclos.*;
import com.rudyreyes.pascalcompiler.modelo.instrucciones.sentenciaTransferencia.*;
//expresiones
import com.rudyreyes.pascalcompiler.modelo.expresiones.nativo.*;
import com.rudyreyes.pascalcompiler.modelo.expresiones.aritmeticas.*;
import com.rudyreyes.pascalcompiler.modelo.expresiones.relacionales.*;
import com.rudyreyes.pascalcompiler.modelo.expresiones.logicas.*;
import com.rudyreyes.pascalcompiler.modelo.expresiones.variables.*;

import com.rudyreyes.pascalcompiler.modelo.errores.*;

// parser
parser code
{:
    scanner s;
    parser(scanner s){this.s = s;}
    
    public LinkedList<Errores> listaErrores = new LinkedList<>();
    
    public void syntax_error(Symbol s){
        listaErrores.add(new Errores("SINTACTICO RECUPERABLE",
                        "No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        listaErrores.add(new Errores("SINTACTICO NO RECUPERABLE",
                        "No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

:}

action code
{:
:}

//terminales
terminal String CADENA, ENTERO, DECIMAL, ID;
terminal FINCADENA, IMPRIMIR;
terminal BEGIN, END, PUNTO, VAR, CONST, DOSPUNTOS, COMA, TYPE;
terminal INTEGER, REAL, VOID, BOOL, STRING, CHAR;
terminal PAR1, PAR2, MAS, MENOS, UMENOS, MULT, DIV, DIVE, MOD;
terminal DIFERENTE, MENOR, MENORIGUAL, MAYOR, MAYORIGUAL, IGUAL;
terminal NOT, AND, THEN, ELSE, OR, ANDT, ORE;
terminal String BOOLEAN, CARACTER;
terminal IF,CASE, OF, WHILE, DO, FOR, TO, REPEAT, UNTIL;
terminal BREAK, CONTINUE, ARRAY, CORCHETE1, CORCHETE2;

//no terminales
nonterminal LinkedList<Instruccion> estructura, instrucciones,cuerpo ;
nonterminal LinkedList<Instruccion> declaracion_constantes;
nonterminal LinkedList<Instruccion> declaraciones_tipos, declaraciones_variables;
nonterminal Instruccion declaracion_tipo, declaracion_variables;
nonterminal Tipo tipos_variable;
nonterminal String tipos_dato_var;
nonterminal Instruccion instruccion, instruccion_fin;
nonterminal Instruccion expresion, expresionAritmetica, expresionRelacional, expresionLogica;
nonterminal LinkedList<Instruccion> expresion_conca;
nonterminal LinkedList<String> listado_id;
nonterminal Instruccion writeln, asignacion_variable, sentencia_if, sentencia_ifelse, opcion_else;
nonterminal Instruccion sentencia_case, sentencia_while, sentencia_for, sentencia_repeat;
nonterminal Instruccion transferencia_break, transferencia_continue;


nonterminal CasoCase caso_case;
nonterminal LinkedList<CasoCase> casos_case;
nonterminal LinkedList<Instruccion> expresiones_case;
 
precedence left ANDT, ORE;
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left IGUAL, DIFERENTE, MENOR, MENORIGUAL,MAYOR,  MAYORIGUAL;
precedence left MAS, MENOS;
precedence left MULT, DIV, MOD, DIVE;
precedence right UMENOS;

start with cuerpo;

cuerpo ::= cuerpo:a estructura:b {: RESULT = a; RESULT.addAll(b); :}
            | estructura: a {: RESULT = new LinkedList<>();  RESULT.addAll(a);:}
;

estructura ::=  TYPE declaraciones_tipos:a {: RESULT = a; :}
                |CONST declaracion_constantes:a {: RESULT = a; :}
                | VAR declaraciones_variables:a {: RESULT = a; :}
                |BEGIN instrucciones:a  END PUNTO    {:   RESULT = a;   :}
;

instrucciones ::= instrucciones:a instruccion:b     {: RESULT = a; RESULT.add(b); :}
                | instruccion:a                     {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

instruccion ::= writeln:a       FINCADENA            {: RESULT= a; :}
                | asignacion_variable:a  FINCADENA   {: RESULT= a; :}
                | sentencia_if :a                    {: RESULT= a; :}
//                | sentencia_ifelse:a                 {: RESULT= a; :}
                | sentencia_case : a                {: RESULT= a; :}
                | sentencia_while:a                 {: RESULT =a; :}
                | sentencia_for:a                 {: RESULT =a; :}
                | sentencia_repeat:a                 {: RESULT =a; :}
                | transferencia_break:a        {: RESULT= a; :}
                | transferencia_continue:a     {: RESULT= a; :}
                | error FINCADENA
                | error 
;

//instruccion_fin ::= writeln:a                   {: RESULT= a; :}
//                | asignacion_variable:a         {: RESULT= a; :}
//                | sentencia_if :a               {: RESULT= a; :}
//                | sentencia_ifelse:a            {: RESULT= a; :}
//;

declaraciones_tipos ::=declaraciones_tipos:a declaracion_tipo:b {: RESULT = a; RESULT.add(b); :}
                    | declaracion_tipo:a {: RESULT = new LinkedList<>(); RESULT.add(a); :}

;

declaracion_tipo ::=   listado_id:a IGUAL tipos_variable:b FINCADENA 
                                    {: RESULT = new DeclaracionTipos(a, b,aleft, aright);  :}
                      
                      |listado_id:a IGUAL expresion:b PUNTO PUNTO PUNTO expresion:c FINCADENA 
                                    {: RESULT = new DeclaracionTipoSubRango(a, b,c, aleft, aright);  :}
                      | listado_id:a IGUAL ARRAY CORCHETE1 expresion:b PUNTO PUNTO expresion:c CORCHETE2 OF tipos_variable:d FINCADENA
                                    {: RESULT = new DeclaracionTipoArreglo(a,b,c, d, aleft, aright); :}
                      | error FINCADENA
                      | error 
;

declaracion_constantes ::=   declaracion_constantes:a ID:b IGUAL expresion:c FINCADENA 
                                    {:RESULT = a;  
                                    RESULT.add(new DeclaracionConstante(false, b,c, new Tipo(TipoDato.INTEGER),bleft, bright)); :}  
                        |ID:b IGUAL expresion:c FINCADENA  
                                                    {:RESULT = new LinkedList<Instruccion>(); 
                                                    RESULT.add(new DeclaracionConstante(false, b,c, new Tipo(TipoDato.INTEGER),bleft, bright)); :}

                        | error FINCADENA
                        | error 
;

declaraciones_variables ::= declaraciones_variables:a declaracion_variables:b {: RESULT = a; RESULT.add(b); :}
                        | declaracion_variables:a  {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;
declaracion_variables ::= listado_id:a DOSPUNTOS tipos_dato_var:b FINCADENA 
                                    {:RESULT = new DeclaracionVariable(true, a,null, b,aleft, aright); :}
                        |listado_id:a DOSPUNTOS expresion:b PUNTO PUNTO PUNTO expresion:c FINCADENA 
                                    {: RESULT = new DeclaracionVarSubrango(a, b,c, aleft, aright);  :}
                        |listado_id:a DOSPUNTOS ARRAY CORCHETE1 expresion:b PUNTO PUNTO expresion:c CORCHETE2 OF tipos_dato_var:d FINCADENA
                                    {: RESULT = new DeclaracionVarArreglo(a,b,c, d, aleft, aright); :}
                        | error FINCADENA
                        | error 
;

listado_id ::= listado_id:a COMA ID:e {: RESULT = a;
                                                    RESULT.add(e);:}
            | ID:a {:RESULT = new LinkedList<String>(); 
                                                    RESULT.add(a);:}
;

tipos_variable ::= INTEGER       {:   RESULT=new Tipo("integer",TipoDato.INTEGER);   :}
                | REAL    {:   RESULT=new Tipo("real",TipoDato.REAL);   :}
                | STRING    {:   RESULT=new Tipo("string",TipoDato.CADENA);   :}
                | CHAR      {:   RESULT=new Tipo("char",TipoDato.CARACTER);   :}
                | BOOL      {:   RESULT=new Tipo("boolean",TipoDato.BOOLEANO);   :}
                | VOID      {:   RESULT=new Tipo("void",TipoDato.VOID);   :}
;

tipos_dato_var ::= INTEGER       {:   RESULT="integer";   :}
                | REAL    {:   RESULT="real";   :}
                | STRING    {:   RESULT="string";   :}
                | CHAR      {:   RESULT="char";   :}
                | BOOL      {:   RESULT="boolean";   :}
                | VOID      {:   RESULT="void";   :}
                | ID:a      {: RESULT = a ;:}
;


//INSTRUCCIONES BEGIN END .

writeln ::= IMPRIMIR PAR1 expresion_conca:a PAR2       {:    RESULT = new Writeln(a, aleft, aright);   :}
;
expresion_conca ::= expresion_conca:a COMA expresion:b           {: RESULT = a;
                                                    RESULT.add(b);:}
                | expresion:a  {:RESULT = new LinkedList<>(); 
                                                    RESULT.add(a);:}
;

 asignacion_variable ::= ID:a DOSPUNTOS IGUAL expresion:b   {:   RESULT=new AsignacionVariable(a, b, aleft, aright);  :}
;


sentencia_if ::= IF PAR1 expresion:a PAR2 THEN instruccion:b {:  RESULT = new SentenciaIf(a, new LinkedList<>(Collections.singletonList(b)), aleft, aright);:}
                |IF PAR1 expresion:a PAR2 THEN BEGIN instrucciones:b END FINCADENA {:   RESULT = new SentenciaIf(a, b, aleft, aright);   :}
               

;

//sentencia_if ::= IF PAR1 expresion:a PAR2 THEN instruccion:b opcion_else:c {: RESULT = c == null ? new SentenciaIf(a, new LinkedList<>(Collections.singletonList(b)), aleft, aright) : new SentenciaIfElse(a, new LinkedList<>(Collections.singletonList(b)), c, aleft, aright); :}
//               | IF PAR1 expresion:a PAR2 THEN BEGIN instrucciones:b END opcion_else:c {: RESULT = c == null ? new SentenciaIf(a, b, aleft, aright) : new SentenciaIfElse(a, b, c, aleft, aright); :}
//;

//opcion_else ::= ELSE instruccion:a {: RESULT = new LinkedList<>(Collections.singletonList(a)); :}
//              | ELSE BEGIN instrucciones:b END  {: RESULT = b; :}
//              | /* vacio */ {: RESULT = null; :}
//;

//sentencia_ifelse ::= IF PAR1 expresion:a PAR2 THEN instruccion:b ELSE  instruccion:c {:  RESULT = new SentenciaIfElse(a, new LinkedList<>(Collections.singletonList(b)), new LinkedList<>(Collections.singletonList(c)), aleft, aright);:}
//                |IF PAR1 expresion:a PAR2 THEN BEGIN instrucciones:b END ELSE  instruccion:c {:   RESULT = new SentenciaIfElse(a, b,new LinkedList<>(Collections.singletonList(c)) , aleft, aright);   :}
//                |IF PAR1 expresion:a PAR2 THEN instruccion:b ELSE BEGIN instrucciones:c END FINCADENA {:   RESULT = new SentenciaIfElse(a, new LinkedList<>(Collections.singletonList(b)),c , aleft, aright);   :}
//                |IF PAR1 expresion:a PAR2 THEN BEGIN instrucciones:b END ELSE BEGIN instrucciones:c END FINCADENA {:   RESULT = new SentenciaIfElse(a, b,c , aleft, aright);   :}
//;


sentencia_case ::= CASE PAR1 expresion:a PAR2 OF casos_case:b ELSE BEGIN instrucciones:c  END FINCADENA {:
                        RESULT = new SentenciaCase(a, b, c, aleft, aright);
                    :}

//                    | CASE PAR1 expresion:a PAR2 OF casos_case:b  {:
//                        RESULT = new SentenciaCase(a, b, null, aleft, aright);
//                   :}

                  | CASE PAR1 expresion:a PAR2 OF casos_case:b ELSE  instruccion:c  END FINCADENA {:
                        RESULT = new SentenciaCase(a, b, new LinkedList<>(Collections.singletonList(c)), aleft, aright);
                    :}


;

casos_case ::= casos_case:a caso_case:b {:RESULT = a; RESULT.add(b);:}
            | caso_case:a {:RESULT = new LinkedList<>(); RESULT.add(a);:}
;

caso_case ::=  expresiones_case:a DOSPUNTOS BEGIN instrucciones:b END FINCADENA{:RESULT = new CasoCase(a, b); :}
            | expresiones_case:a DOSPUNTOS instruccion:b {:RESULT = new CasoCase(a, new LinkedList<>(Collections.singletonList(b))); :}
;

expresiones_case ::= expresiones_case:a COMA expresion:b {:RESULT = a; RESULT.add(b);:}
                    | expresion:a {:RESULT = new LinkedList<>(); RESULT.add(a);:}

;

sentencia_while ::= WHILE PAR1 expresion:a PAR2 DO BEGIN instrucciones:b END FINCADENA  {:   RESULT = new SentenciaWhile(a, b, aleft, aright);   :}
                | WHILE PAR1 expresion:a PAR2 DO instruccion:b  {:   RESULT = new SentenciaWhile(a,new LinkedList<>(Collections.singletonList(b)), aleft, aright);   :}
;

sentencia_for ::= FOR ID:a DOSPUNTOS IGUAL expresion:b TO expresion:c DO instruccion:d     
                {:RESULT = new SentenciaFor(new AsignacionVariable(a, b, aleft, aright), c, new AccesoVariable(a, aleft, aright) , new LinkedList<>(Collections.singletonList(d)),new AsignacionVariable(a, new OperacionSuma(new AccesoVariable(a, aleft, aright), new Nativo(1, new Tipo("integer",TipoDato.INTEGER), aleft, aright) , aleft, aright), aleft, aright),aleft, aright);   :}


                |FOR ID:a DOSPUNTOS IGUAL expresion:b TO expresion:c DO BEGIN instrucciones:d END FINCADENA    
                {:  		   RESULT = new SentenciaFor(new AsignacionVariable(a, b, aleft, aright), c, new AccesoVariable(a, aleft, aright) , d,new AsignacionVariable(a, new OperacionSuma(new AccesoVariable(a, aleft, aright), new Nativo(1, new Tipo("integer",TipoDato.INTEGER), aleft, aright) , aleft, aright), aleft, aright),aleft, aright);   
                 :}


;

sentencia_repeat ::= REPEAT  instrucciones:b  UNTIL expresion:a  FINCADENA {:   RESULT = new SentenciaRepeat(a, b, aleft, aright);   :}

;

transferencia_break::=  BREAK:a FINCADENA      {:    RESULT = new SentenciaBreak(aleft, aright);     :}
;

transferencia_continue::=  CONTINUE:a FINCADENA      {:    RESULT = new SentenciaContinue(aleft, aright);     :}
;

//AGREGAR UNA EXPRESION COMA
expresion ::=  expresionAritmetica:a        {: RESULT = a; :}
            | expresionRelacional: a        {: RESULT = a; :}
            | expresionLogica:a             {: RESULT = a; :}
            | ENTERO:a                      {:   RESULT = new Nativo(Integer.parseInt(a), new Tipo("integer",TipoDato.INTEGER), aleft, aright );   :}
            | DECIMAL:a                     {:   RESULT = new Nativo(new Double(a), new Tipo("real",TipoDato.REAL), aleft, aright );   :}
            | CADENA:a                      {:   RESULT = new Nativo(a, new Tipo("string",TipoDato.CADENA), aleft, aright );   :}
            | CARACTER:a                    {:   RESULT = new Nativo(a, new Tipo("char",TipoDato.CARACTER), aleft, aright );   :}
            | BOOLEAN:a                     {:   RESULT = new Nativo(Boolean.parseBoolean(a), new Tipo("boolean",TipoDato.BOOLEANO), aleft, aright );   :}
            | ID:a                          {:   RESULT = new AccesoVariable(a, aleft, aright);   :}
;

expresionAritmetica ::= MENOS expresion:a             {:   RESULT = new OperacionNegacionU(a, aleft, aright);   :} %prec UMENOS
            | expresion:a MAS expresion:b           {:   RESULT = new OperacionSuma(a, b, aleft, aright);   :}
            | expresion:a MENOS expresion:b         {:  RESULT = new OperacionResta(a, b, aleft, aright);  :}
            | expresion:a MULT expresion:b          {:   RESULT = new OperacionMultiplicacion(a, b, aleft, aright);   :}
            | expresion:a DIV expresion:b           {:  RESULT = new OperacionDivision (a, b, aleft, aright);   :}
            | expresion:a DIVE expresion:b           {:  RESULT = new OperacionDiv(a, b, aleft, aright);   :}
            | expresion:a MOD expresion:b           {:  RESULT = new OperacionModulo (a, b, aleft, aright);   :}
            | PAR1 expresion:a PAR2                 {:   RESULT = a;   :}
;



expresionRelacional ::= expresion:a IGUAL expresion:b   {:   RESULT = new Igualacion(a, b, aleft, aright);   :} %prec IGUAL
                    | expresion:a DIFERENTE expresion:b     {:   RESULT = new Diferenciacion(a, b, aleft, aright);   :} %prec DIFERENTE
                    | expresion:a MENOR expresion:b         {:   RESULT = new MenorQue(a, b, aleft, aright);   :} %prec MENOR
                    | expresion:a MENORIGUAL expresion:b    {:   RESULT = new MenorIgualQue(a, b, aleft, aright);   :} %prec MENORIGUAL
                    | expresion:a MAYOR expresion:b         {:   RESULT = new MayorQue(a, b, aleft, aright);   :} %prec MAYOR
                    | expresion:a MAYORIGUAL expresion:b    {:   RESULT = new MayorIgualQue(a, b, aleft, aright);   :} %prec MAYORIGUAL

;

expresionLogica ::= NOT expresion:a                 {:   RESULT = new OperadorNot(a, aleft, aright);   :} %prec NOT
                | expresion:a AND expresion:b       {:   RESULT = new OperadorAnd(a, b, aleft, aright);   :} %prec AND
                | expresion:a OR expresion:b        {:   RESULT = new OperadorOr(a, b, aleft, aright);   :} %prec OR
                | expresion:a AND THEN expresion:b        {:   RESULT = new OperadorAndThen(a, b, aleft, aright);   :} %prec ANDT
                | expresion:a OR ELSE expresion:b        {:   RESULT = new OperadorOrThen(a, b, aleft, aright);   :} %prec ORE

;